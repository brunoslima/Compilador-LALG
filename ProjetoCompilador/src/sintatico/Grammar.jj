options
{
  
}
PARSER_BEGIN(Grammar)
package sintatico;

public class Grammar
{

static void error_skipto(int kind) {
  ParseException e = generateParseException();  // generate the exception object.
  //System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);

}

static void error_skipto_before(int kind) {
  ParseException e = generateParseException();  // generate the exception object.
  //System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
    t.next = Token.newToken(getToken(1).kind, getToken(1).image);
  } while (t.next == null || t.next.kind != kind);

}

static void error_skipto(int kind1, int kind2) {
  ParseException e = generateParseException();  // generate the exception object.
  //System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind1 && t.kind != kind2);
}

static void error_skipto_before(int kind1, int kind2) {
  ParseException e = generateParseException();  // generate the exception object.
  //System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
    t.next = Token.newToken(getToken(1).kind, getToken(1).image);
  } while (t.next.kind != kind1 && t.next.kind != kind2);
}

static void showMessageError(int line, int column, String message, String descricao){
    
    System.out.println("\n=========================\n" +
        message + "\n" +
        "Linha: " + line + " Coluna: " + column + "\n" +
        descricao
    );
}

}
PARSER_END(Grammar)


TOKEN:
{

    < PROGRAM: "program" >
|   < BEGIN: "begin" >
|   < END: "end" >
|   < PROCEDURE: "procedure" >
|   < VAR: "var" >

|   < INT: "int" >
|   < REAL: "real" >
|   < BOOLEAN: "boolean" >
|   < TRUE: "true" >
|   < FALSE: "false" >

|   < READ: "read" >
|   < WRITE: "write" >

|   < DOIS_PONTOS: ":" >
|   < PONTO_VIRGULA: ";" >
|   < VIRGULA: "," >
|   < PONTO: "." >

|   < IF: "if" >
|   < THEN: "then" >
|   < ELSE: "else" >

|   < WHILE: "while" >
|   < DO: "do" >

|   < SIMBOLO_IGUAL: "=" >
|   < SIMBOLO_DIFERENTE: "<>" >
|   < SIMBOLO_MENOR: "<" >
|   < SIMBOLO_MENOR_IGUAL: "<=" >
|   < SIMBOLO_MAIOR: ">" >
|   < SIMBOLO_MAIOR_IGUAL: ">=" >

|   < OP_ATRIBUICAO: ":=" >
|   < OP_ADICAO: "+" >
|   < OP_SUBTRACAO: "-" >
|   < OP_DIVISAO: "div" >
|   < OP_MULTIPLICACAO: "*" >
|   < OP_AND: "and" >
|   < OP_OR: "or" >
|   < OP_NOT: "not" >

|   < PARENTESES_ABRE: "(" >
|   < PARENTESES_FECHA: ")" >


|   < NUMERO_INTEIRO: (["0"-"9"]){1,10} >
|   < NUMERO_REAL:  (["0"-"9"])+ ( "." (["0"-"9"]){1,6} ) >


|   < IDENTIFICADOR: ["_", "A"-"Z", "a"-"z"](["_", "A"-"Z", "a"-"z"] | (["0"-"9"]) )* >


}

SKIP :
{
    " "
|   "\r"
|   "\t"
|   "\n"
|   <"{" (~["}"] )* "}">
|   <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>

}

void compilationUnit() :
{}
{
    try{
        programDeclaration() 
    }
    catch(ParseException e){
        {showMessageError(token.next.beginLine, token.next.beginColumn, "Palavra reservada program esperada", "Descrição");}
        error_skipto(PONTO_VIRGULA);
    }

    bloco()
    {token.next = Token.newToken(getToken(1).kind, getToken(1).image);}

    try{
        <PONTO>
    }
    catch(ParseException e){
        showMessageError(e.currentToken.beginLine, e.currentToken.beginColumn, "Ponto final faltando", "Descrição");
    }

    <EOF>
}

void programDeclaration() throws ParseException:
{}
{
    (
        <PROGRAM>
    |
        {throw generateParseException();}
    )
    
    (
        <IDENTIFICADOR>
    |
        {showMessageError(token.beginLine, token.beginColumn, "Identificador de programa faltando", "Descrição");}
    )
     
    (
        <PONTO_VIRGULA>
    |
        {showMessageError(token.beginLine, token.beginColumn, "Ponto e vírgula faltando", "Descrição");}
    )

}

void bloco() :
{}
{   
    
    [
        //LOOKAHEAD(tipo() <IDENTIFICADOR> (<PONTO_VIRGULA>|<VIRGULA>) )
        parteDeclaracaoVariaveis()
    ]
    (
        LOOKAHEAD(<PROCEDURE> <IDENTIFICADOR> <PARENTESES_ABRE>)
        parteDeclaracaoSubRotinas() 
        
        (
            <PONTO_VIRGULA>
        |
            {showMessageError(token.next.beginLine, token.next.beginColumn, "Ponto e vírgula faltando", "Descrição");}
        )
    )*

    comandoComposto()
}

void parteDeclaracaoVariaveis():
{}
{
    ( 
        try{
            declaracaoVariaveis() 
        }
        catch(ParseException e){
            error_skipto(PONTO_VIRGULA);
        }

        (
            try{
                declaracaoVariaveis()
            }
            catch(ParseException e){
                error_skipto(PONTO_VIRGULA);
            }
        )* 
    )
   
}

void declaracaoVariaveis() throws ParseException:
{}
{
    tipo() 
    listaIdentificadores()
    (
        LOOKAHEAD(<PONTO_VIRGULA>)
        <PONTO_VIRGULA>
        |
        {showMessageError(token.next.beginLine, token.next.beginColumn, "Ponto e vírgula faltando", "Descrição");}
    )
}

void listaIdentificadores() :
{}
{ 
    ( 
        variavel() 
        (
            /*try{
                <VIRGULA>
            }
            catch(ParseException e){
                
                showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Vírgula esperada", "Descrição");
            }*/ //Antigo tratamento das virgulas na lista de variaveis
            LOOKAHEAD(<VIRGULA><IDENTIFICADOR>|<IDENTIFICADOR>|<VIRGULA>)
            (   <VIRGULA>
                |
                {showMessageError(token.beginLine, token.beginColumn, "Vírgula faltando", "Descrição");}
            )
            variavel()
        )* 
    )
}



void parteDeclaracaoSubRotinas() :
{}
{   
    
    try{
        <PROCEDURE>
    }
    catch(ParseException e){
        showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Palavra reservada procedure esperada", "Descrição");
    }

    try{
        <IDENTIFICADOR>
    }
    catch(ParseException e){
        showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Identificador de procedure esperado", "Descrição");
    }


    declaracaoProcedimentos() 

}



void declaracaoProcedimentos() :
{}
{    
    ( 
        [
            try{
                <PARENTESES_ABRE>
            }
            catch(ParseException e){
                showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Abre parentese faltando", "Descrição");
            }

            parametrosFormais() 

            try{
                <PARENTESES_FECHA>
            }
            catch(ParseException e){
                showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Fecha parenteses faltando", "Descrição");
            }
        ] 

        try{
            <PONTO_VIRGULA>
        }
        catch(ParseException e){
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Ponto e vírgula faltando", "Descrição");
        }
        bloco() 
    ) 

}

void parametrosFormais() : 
{}
{
    
    secaoParametrosFormais() 
    (
        try{
            <PONTO_VIRGULA>
        }
        catch(ParseException e){
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Ponto e vírgula faltando", "Descrição");
        } 
        secaoParametrosFormais()
    )*

}

void secaoParametrosFormais() :
{}
{
    ( 
        [
            try{
                <VAR>
            }
            catch(ParseException e){
                showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Palavra reservada var esperada", "Descrição");
            }
        ] 

        listaIdentificadores() 
        
        try{
            <DOIS_PONTOS>
        }
        catch(ParseException e){
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Dois pontos faltando", "Descrição");
        }
        
        tipo() 
    )

}

void tipo() throws ParseException:
{}
{

    
    <INT> 
    | 
    <BOOLEAN> 
    | 
    <REAL>
    |
    (
        {
            showMessageError(token.next.beginLine, token.next.beginColumn, "Identificador de tipo esperado", "Descrição");
            throw generateParseException();
        }
    )
    
}

///////////////////////////////////////
///////////////////////////////////////
///////////////////////////////////////

void comandoComposto():
{}
{
    ( 
        try{
            <BEGIN> 
        }
        catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Palavra reservada begin esperada", "Descrição");
        }

        try{
            comando() 
        }
        catch(ParseException e){
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Comando estruturado incorretamente", "Descrição");
            error_skipto_before(PONTO_VIRGULA, END);
        }

        (
            try{
                
                <PONTO_VIRGULA>
            }
            catch(ParseException e){
                showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Ponto e vírgula faltando", "Descrição");
            } 

            try{
                comando() 
            }
            catch(ParseException e){
                showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Comando estruturado incorretamente", "Descrição");
                error_skipto_before(PONTO_VIRGULA, END);
            }
        )* 

        try{
            <END>
        }
        catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Palavra reservada end esperada", "Descrição");
        }

    )

}

void comando() :
{}
{   
    LOOKAHEAD(<IDENTIFICADOR> <OP_ATRIBUICAO>)
    (
        
        atribuicao()
    )
    | 
    LOOKAHEAD(<IDENTIFICADOR> <PARENTESES_ABRE> expressao() <PARENTESES_FECHA> <PONTO_VIRGULA>)
    (
        
        chamadaProcedimento() 
    )
    |
    LOOKAHEAD(<BEGIN>)
    (
        comandoComposto() 
    )
    | 
    LOOKAHEAD(<IF> <PARENTESES_ABRE> expressao() <PARENTESES_FECHA> <THEN>)
    (    
        comandoCondicional() 
    )
    | 
    LOOKAHEAD(<WHILE>)
    (
        comandoRepetitivo()
    )
    |
    LOOKAHEAD(<READ>)
    ( 
        try{
            <READ> 
        }
        catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Palavra reservada read esperada", "Descrição");
        }
        try{
            <PARENTESES_ABRE> 
        }
        catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Abre parenteses esperado", "Descrição");
        }
        
        listaIdentificadores() 
        try{
            <PARENTESES_FECHA> 
        }
        catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Fecha parenteses esperado", "Descrição");
        }
    )
    | 
    LOOKAHEAD(<WRITE>)
    ( 
        try{
            <WRITE> 
        }
        catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Palavra reservada write esperada", "Descrição");
        }
        try{
            <PARENTESES_ABRE> 
        }
        catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Abre parenteses esperado", "Descrição");
        }
        listaIdentificadores() 
        try{
            <PARENTESES_FECHA> 
        }
        catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Fecha parenteses esperado", "Descrição");
        }
        
    )
    |
    (
        {throw generateParseException();}
    )

}

void atribuicao() :
{}
{

    ( 
        variavel() 
        try{
            <OP_ATRIBUICAO >
        }
        catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Operador de atribuição esperado", "Descrição");
        }
        
        (   
            LOOKAHEAD(<PONTO_VIRGULA>|<END>)
            (
                    {showMessageError(token.next.beginLine, token.next.beginColumn, "Faltou informar o que será atribuido", "Descrição");
                    error_skipto(PONTO_VIRGULA,END);}
            )
            |
            expressao() 
        )
    )

}

void chamadaProcedimento() :
{}
{

    ( 
        try{
            <IDENTIFICADOR> 
        }
        catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Identificador de procedimento esperado", "Descrição");
        }
        try{
            <PARENTESES_ABRE> 
        }
        catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Abre parenteses esperado", "Descrição");
        }
        listaExpressoes() 
        try{
            <PARENTESES_FECHA> 
        }
        catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Fecha parenteses esperado", "Descrição");
        }
    )

}

void comandoCondicional() throws ParseException:
{}
{
    (
        <IF>
        |
        {showMessageError(token.next.beginLine, token.next.beginColumn, "Palavra reservada IF esperada", "Descrição");
        throw generateParseException();}
    )
    
    expressao()
    
    (
        <THEN>
        |
        {showMessageError(token.next.beginLine, token.next.beginColumn, "Palavra reservada THEN esperada", "Descrição");
        throw generateParseException();}
    ) 
    
    comando() 
    
    
    [ LOOKAHEAD(1) <ELSE> comando()]

}

void comandoRepetitivo() throws ParseException:
{}
{
    ( 
        <WHILE>    
        |
        {showMessageError(token.next.beginLine, token.next.beginColumn, "Palavra reservada WHILE esperada", "Descrição");
        throw generateParseException();}
    )

    expressao()
    
    (
        <DO>
        |
        {showMessageError(token.next.beginLine, token.next.beginColumn, "Palavra reservada IF esperada", "Descrição");
        throw generateParseException();}
    )

    comando() 
    
}

void expressao() :
{}
{
    expressaoSimples() [relacao() expressaoSimples()]
}

void expressaoSimples() :
{}
{
    [
    try{
        <OP_ADICAO>
        |
        <OP_SUBTRACAO>
    }catch(ParseException e){
        
        showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Operador de adição ou subtração esperado", "Descrição");
    }
    ]

    
    termo()

    (
        LOOKAHEAD(<OP_ADICAO> | <OP_SUBTRACAO> | <OP_OR>)
        (
            try{
                <OP_ADICAO> | <OP_SUBTRACAO> | <OP_OR>
            }catch(ParseException e){
        
                showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Operador de adição ou subtração ou OR esperado", "Descrição");
            } 
        ) 
        termo()
    )*
}

void relacao() :
{}
{
    (
        try{
            <SIMBOLO_IGUAL> | <SIMBOLO_DIFERENTE> | <SIMBOLO_MENOR> | <SIMBOLO_MENOR_IGUAL> | <SIMBOLO_MAIOR_IGUAL> | <SIMBOLO_MAIOR>
        }catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Operador logico esperado", "Descrição");
        } 
    )
}

void termo() :
{}
{
    fator() 
    (
        (
            try{
                <OP_MULTIPLICACAO> | <OP_DIVISAO> | <OP_AND>
            }catch(ParseException e){
        
                showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Operador de multiplicação ou adição ou divisão esperado", "Descrição");
            } 
        ) 
        fator()
    )*
}


void fator() :
{}
{
    variavel() | 
    try{ 
        <NUMERO_INTEIRO> | <NUMERO_REAL>
    }catch(ParseException e){
        
        showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Número inteiro ou real esperado", "Descrição");
    } 
    |
    (
        try{
            <PARENTESES_ABRE>
        }catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Abre parenteses esperado", "Descrição");
        }  
        expressao()
        try{
            <PARENTESES_FECHA>
        }catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Fecha parenteses esperado", "Descrição");
        } 
    ) 
    | 
    (
        try{
           <OP_NOT>
        }catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Operador not esperado", "Descrição");
        }
        fator()
    )
    | 
    try{
        <TRUE> | <FALSE>
    }catch(ParseException e){
        
        showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Tipo de dado boleano(TRUE ou FALSE) esperado", "Descrição");
    } 
}

void listaExpressoes() :
{}
{
    expressao() 

    (
        try{
            <VIRGULA>
        }catch(ParseException e){
        
            showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Virgula esperada", "Descrição");
        }  
        expressao()
    )*
}


void variavel() :
{}
{
    try{
        <IDENTIFICADOR>
    }catch(ParseException e){
        
        showMessageError(e.currentToken.next.beginLine, e.currentToken.next.beginColumn, "Identificador esperado", "Descrição");
    } 
}
